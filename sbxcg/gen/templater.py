# SPDX-License-Identifier: LGPL-3.0-or-later
################################################################################
# shadowblox - https://git.seki.pw/Fumohouse/shadowblox
#
# Copyright 2025-present ksk.
# Copyright 2025-present shadowblox contributors.
#
# Licensed under the GNU Lesser General Public License version 3.0 or later.
# See COPYRIGHT.txt for more details.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
################################################################################

import json
import re

from .. import constants

hpp_header_regex = r"// SBXCG CLASS HEADER (?P<name>\S+) (?P<json>\{.*\})"
cpp_header_regex = r"// SBXCG CLASS SOURCE (?P<name>\S+)"
block_regex = r"/\* BEGIN USER CODE (?P<name>.*?) \*/\n*(?P<contents>[\S\s]*?)\s*/\* END USER CODE .*?\*/"

header_sbxcg = """/*******************************************************************************
 * NOTE: This file is partially auto-generated by sbxcg. Modifications outside
 * BEGIN USER CODE <name> and END USER CODE comment blocks will be lost!
 * The sbxcg tool is present at the root of this project and can be invoked with
 * `python3 -m sbxcg`. See the developer documentation for more details.
 ******************************************************************************/"""


def make_block(
    name: str,
    blocks: dict[str, str],
    base_indent: int = 0,
    content_indent: int = 0,
):
    return f"""{"\t" * base_indent}// clang-format on
{"\t" * base_indent}/* BEGIN USER CODE {name} */
{"\t" * content_indent}{blocks.get(name, "")}
{"\t" * base_indent}/* END USER CODE {name} */
{"\t" * base_indent}// clang-format off"""


def extract_blocks(contents: str):
    blocks: dict[str, str] = {}

    for match in re.finditer(block_regex, contents):
        blocks[match.group("name")] = match.group("contents")

    return blocks


def parse_header(contents: str):
    res = re.search(hpp_header_regex, contents)
    if res is None:
        return None

    return res.group("name"), json.loads(res.group("json")), extract_blocks(contents)


def parse_source(contents: str):
    res = re.search(cpp_header_regex, contents)
    if res is None:
        return None

    return res.group("name"), extract_blocks(contents)


def generate_includes(includes: set[str]):
    return "\n".join(["#include " + h + " // NOLINT" for h in includes])


def should_skip_space(type: str):
    return type.endswith("*") or type.endswith("&")


def convert_type(type: dict, self: str, includes: set[str], classes: dict) -> str:
    category: str = type["Category"]
    name: str = type["Name"]

    if name.endswith("?"):
        includes.add("<optional>")
        return f"std::optional<{convert_type({'Category': category, 'Name': name[:-1]}, self, includes, classes)}>"
    elif name.endswith("[]"):
        includes.add("<vector>")
        return f"std::vector<{convert_type({'Category': category, 'Name': name[:-2]}, self, includes, classes)}>"
    elif category == "Class":
        header = classes.get(name, {}).get("header", f"{name}.hpp")
        if name != self:
            includes.add(f'"Sbx/Classes/{header}"')
        includes.add("<memory>")
        return f"std::shared_ptr<{name}>"
    elif category == "Enum":
        includes.add('"Sbx/DataTypes/EnumTypes.gen.hpp"')
        return "Enum" + name
    elif name in constants.type_map:
        res = constants.type_map[name]
        if "include" in res:
            includes.add(res["include"])
        return res["type"]

    return name


def generate_sig(dump_member: dict, self: str, includes: set[str], classes: dict):
    return_type = dump_member.get("ReturnType")
    parameters = dump_member.get("Parameters", [])

    ret_type = "void"
    if return_type is not None:
        ret_type = convert_type(return_type, self, includes, classes)

    param_types = ""
    if len(parameters) > 0:
        param_types = ", ".join(
            [convert_type(p["Type"], self, includes, classes) for p in parameters]
        )

    return f"{ret_type}({param_types})"


def generate_func(dump_member: dict, self: str, includes: set[str], classes: dict):
    return_type = dump_member.get("ReturnType")
    parameters = dump_member.get("Parameters", [])

    ret_type = "void"
    if return_type is not None:
        ret_type = convert_type(return_type, self, includes, classes)

    params = []
    for param in parameters:
        conv_type = convert_type(param["Type"], self, includes, classes)
        if should_skip_space(conv_type):
            params.append(conv_type + param["Name"])
        else:
            params.append(conv_type + " " + param["Name"])

    return ret_type, ", ".join(params)


def generate_param_names(dump_member: dict, includes: set[str], classes: dict):
    parameters = dump_member.get("Parameters", [])
    if len(parameters) == 0:
        return ""

    return f", {', '.join([f'"{p["Name"]}"' for p in parameters])}"


def generate_security(security: str):
    if security == "None":
        return "NoneSecurity"
    return security


def generate_member_tags(dump_member: dict):
    tags = dump_member.get("Tags", [])
    if len(tags) == 0:
        return "{ }"

    tags = [t for t in tags if t not in constants.auto_tags]

    tags_str = ", ".join(["MemberTag::" + t for t in tags])
    return f"{{ {tags_str} }}"


def generate_safety(dump_member: dict):
    safety = dump_member["ThreadSafety"]
    return "ThreadSafety::" + safety


def generate_members(
    dump_class: dict, config_members: dict, classes: dict, source_blocks: dict[str, str]
):
    class_name = dump_class["Name"]
    dump_members = dump_class["Members"]

    members: list[dict] = []
    header_includes: set[str] = set()
    source_includes: set[str] = set()

    for name, config in config_members.items():
        dump_member = [m for m in dump_members if m["Name"] == name]
        if len(dump_member) == 0:
            print(f"WARNING: Member {name} no longer exists")
            continue
        dump_member = dump_member[0]

        member_type = dump_member["MemberType"]

        member_data = {
            "name": name,
            "type": member_type,
        }

        tags = generate_member_tags(dump_member)

        if member_type == "Property":
            category = dump_member["Category"]

            type = convert_type(
                dump_member["ValueType"], class_name, header_includes, classes
            )
            convert_type(dump_member["ValueType"], class_name, source_includes, classes)

            safety = generate_safety(dump_member)
            can_load = "true" if dump_member["Serialization"]["CanLoad"] else "false"
            can_save = "true" if dump_member["Serialization"]["CanSave"] else "false"

            is_read_only = "ReadOnly" in dump_member.get("Tags", [])
            is_not_scriptable = "NotScriptable" in dump_member.get("Tags", [])

            alias = config.get("alias")
            getter_ptr = f"&{class_name}::Get{alias if alias is not None else name}"
            setter_ptr = f"&{class_name}::Set{alias if alias is not None else name}"

            if is_not_scriptable:
                if is_read_only:
                    member_data["bind"] = (
                        f'ClassDB::BindPropertyNotScriptableReadOnly<T, "{name}", "{category}", {getter_ptr}, {safety}, {can_save}>({tags});'
                    )
                else:
                    member_data["bind"] = (
                        f'ClassDB::BindPropertyNotScriptable<T, "{name}", "{category}", {getter_ptr}, {setter_ptr}, {safety}, {can_load}, {can_save}>({tags});'
                    )
            else:
                read_security = generate_security(dump_member["Security"]["Read"])
                write_security = generate_security(dump_member["Security"]["Write"])

                if is_read_only:
                    member_data["bind"] = (
                        f'ClassDB::BindPropertyReadOnly<T, "{name}", "{category}", {getter_ptr}, {read_security}, {safety}, {can_save}>({tags});'
                    )
                else:
                    member_data["bind"] = (
                        f'ClassDB::BindProperty<T, "{name}", "{category}", {getter_ptr}, {read_security}, {setter_ptr}, {write_security}, {safety}, {can_load}, {can_save}>({tags});'
                    )

            if alias is None and not (class_name == "Object" and name == "ClassName"):
                getter_virtual_str = (
                    "virtual " if config.get("virtual_get", False) else ""
                )
                setter_virtual_str = (
                    "virtual " if config.get("virtual_set", False) else ""
                )
                spc = "" if should_skip_space(type) else " "

                member_data["decl"] = (
                    f"{getter_virtual_str}{type}{spc}Get{name}() const;"
                )
                member_data[
                    "impl"
                ] = f"""{type}{spc}{class_name}::Get{name}() const {{
{make_block(f"Property{name}Getter", source_blocks, base_indent=1)}
}}"""
                if not is_read_only:
                    member_data[
                        "decl"
                    ] += f"\n\t{setter_virtual_str}void Set{name}({type}{spc}value);"
                    member_data[
                        "impl"
                    ] += f"""\n\nvoid {class_name}::Set{name}({type}{spc}value) {{
{make_block(f"Property{name}Setter", source_blocks, base_indent=1)}
}}"""
        elif member_type == "Function":
            security = generate_security(dump_member["Security"])
            param_names = generate_param_names(dump_member, header_includes, classes)
            safety = generate_safety(dump_member)

            alias = config.get("alias")
            custom = (
                config.get("custom", False)
                if alias is None
                else config_members.get(alias, {}).get("custom", False)
            )
            func_name = alias if alias is not None else name

            if custom:
                sig = generate_sig(dump_member, class_name, header_includes, classes)

                # Use T:: to allow shadowing by child classes
                member_data["bind"] = (
                    f'ClassDB::BindLuauMethod<T, "{name}", {sig}, &T::{func_name}, {security}, {safety}>({tags}{param_names});'
                )

                if alias is None:
                    header_includes.add('"lua.h"')
                    source_includes.add('"lua.h"')

                    member_data["decl"] = f"static int {func_name}(lua_State *L);"
                    member_data[
                        "impl"
                    ] = f"""int {class_name}::{func_name}(lua_State *L) {{
{make_block(f"Method{name}", source_blocks, base_indent=1)}
}}"""
            else:
                member_data["bind"] = (
                    f'ClassDB::BindMethod<T, "{name}", &{class_name}::{func_name}, {security}, {safety}>({tags}{param_names});'
                )

                if alias is None:
                    ret_type, params = generate_func(
                        dump_member, class_name, header_includes, classes
                    )
                    generate_func(dump_member, class_name, source_includes, classes)

                    hpp_hdr = ""
                    if config.get("virtual", False):
                        hpp_hdr += "virtual "
                    hpp_hdr += ret_type
                    if not should_skip_space(ret_type):
                        hpp_hdr += " "
                    hpp_hdr += f"{name}({params})"
                    if config.get("const", False):
                        hpp_hdr += " const"
                    if config.get("pure", False):
                        hpp_hdr += " = 0"
                    hpp_hdr += ";"

                    member_data["decl"] = hpp_hdr

                    if not config.get("pure", False):
                        cpp_hdr = ret_type
                        if not should_skip_space(ret_type):
                            cpp_hdr += " "
                        cpp_hdr += f"{class_name}::{name}({params})"
                        if config.get("const", False):
                            cpp_hdr += " const"

                        member_data[
                            "impl"
                        ] = f"""{cpp_hdr} {{
{make_block(f"Method{name}", source_blocks, base_indent=1)}
}}"""
        elif member_type == "Event":
            sig = generate_sig(dump_member, class_name, header_includes, classes)
            security = generate_security(dump_member["Security"])
            param_names = generate_param_names(dump_member, header_includes, classes)

            member_data["bind"] = (
                f'ClassDB::BindSignal<T, "{name}", {sig}, {security}>({tags}{param_names});'
            )
        elif member_type == "Callback":
            sig = generate_sig(dump_member, class_name, header_includes, classes)
            security = generate_security(dump_member["Security"])
            param_names = generate_param_names(dump_member, header_includes, classes)
            safety = generate_safety(dump_member)

            member_data["bind"] = (
                f'ClassDB::BindCallback<T, "{name}", {sig}, &{class_name}::Set{name}, {security}, {safety}>({tags}{param_names});'
            )

            header_includes.add('"lua.h"')
            source_includes.add('"lua.h"')

            member_data["decl"] = f"void Set{name}(lua_State *L);"
            member_data[
                "impl"
            ] = f"""void {class_name}::Set{name}(lua_State *L) {{
{make_block(f"Callback{name}Setter", source_blocks, base_indent=1)}
}}"""

        members.append(member_data)

    return members, header_includes, source_includes


def generate(
    dump: dict,
    class_data: dict,
    classes: dict,
):
    # Dump fields
    name = dump["Name"]
    superclass = dump["Superclass"]
    memory_category = dump["MemoryCategory"]
    tags = dump.get("Tags", [])

    # Class data fields
    config = class_data.get("config", {})
    header_blocks = class_data.get("header_blocks", {})
    source_blocks = class_data.get("source_blocks", {})

    # Initial header generation
    header_includes = {'"Sbx/Runtime/Base.hpp"', '"Sbx/Classes/ClassDB.hpp"'}
    source_includes = {f'"Sbx/Classes/{class_data.get("header", f"{name}.hpp")}"'}

    def import_class(name: str):
        import_header = classes.get(name, {}).get("header", f"{superclass}.hpp")
        header_includes.add(f'"Sbx/Classes/{import_header}"')

    if superclass != "<<<ROOT>>>":
        import_class(superclass)

    # Class definition
    extends_class = "ObjectBase" if superclass == "<<<ROOT>>>" else superclass
    sbxextends_class = "" if superclass == "<<<ROOT>>>" else superclass

    if len(tags) > 0:
        tags_str = ", " + ", ".join(["ClassTag::" + t for t in tags])
    else:
        tags_str = ""

    # Members
    gen_members, member_hpp_includes, member_cpp_includes = generate_members(
        dump, config.get("members", {}), classes, source_blocks
    )

    header_includes = header_includes.union(member_hpp_includes)
    source_includes = source_includes.union(member_cpp_includes)

    properties = sorted(
        [m for m in gen_members if m["type"] == "Property"], key=lambda m: m["name"]
    )
    functions = sorted(
        [m for m in gen_members if m["type"] == "Function"], key=lambda m: m["name"]
    )
    signals = sorted(
        [m for m in gen_members if m["type"] == "Event"], key=lambda m: m["name"]
    )
    callbacks = sorted(
        [m for m in gen_members if m["type"] == "Callback"], key=lambda m: m["name"]
    )

    bind_str = ""
    decl_str = ""
    impl_str = ""

    def add_section(section: list[dict]):
        nonlocal bind_str
        nonlocal decl_str
        nonlocal impl_str
        if len(section) == 0:
            return

        bind_str += "\n".join(["\t\t" + m["bind"] for m in section])
        bind_str += "\n\n"

        for m in section:
            if "decl" in m:
                decl_str += "\t" + m["decl"]
                decl_str += "\n\n"
            if "impl" in m:
                impl_str += m["impl"]
                impl_str += "\n\n"

    add_section(properties)
    add_section(functions)
    add_section(signals)
    add_section(callbacks)

    # Header generation
    header = f"""{constants.header_cpp}{header_sbxcg}

// SBXCG CLASS HEADER {name} {json.dumps(config)}
// clang-format off

#pragma once

{generate_includes(header_includes)}

{make_block("PreNamespace", header_blocks)}

namespace SBX::Classes {{

{make_block("PreClass", header_blocks)}

/**
 * @brief This class implements Roblox's [`{name}`](https://create.roblox.com/docs/reference/engine/classes/{name})
 * class.
 */
class {name} : public {extends_class} {{
\tSBXCLASS({name}, {sbxextends_class}, MemoryCategory::{memory_category}{tags_str});

{make_block("ClassExtra1", header_blocks, base_indent=1)}

public:
{decl_str.rstrip()}

protected:
\ttemplate <typename T>
\tstatic void BindMembers() {{
{bind_str.rstrip()}

{make_block("BindExtra", header_blocks, base_indent=2)}
\t}}

{make_block("ClassExtra2", header_blocks, base_indent=1)}
}};

{make_block("PostClass", header_blocks)}

}} //namespace SBX::Classes

{make_block("PostNamespace", header_blocks)}
"""

    # Source generation
    source = f"""{constants.header_cpp}{header_sbxcg}

// SBXCG CLASS SOURCE {name}
// clang-format off

{generate_includes(source_includes)}

{make_block("PreNamespace", source_blocks)}

namespace SBX::Classes {{

{make_block("PreClass", source_blocks)}

{impl_str.rstrip()}

{make_block("PostClass", source_blocks)}

}} //namespace SBX::Classes

{make_block("PostNamespace", source_blocks)}
"""

    return header, source
